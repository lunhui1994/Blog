---
title: JavaScript：leetcode_210. 课程表 II
date: 2020-05-17 17:59:13
categories: ['Algorithm','每日一题']
tags: Algorithm
keywords: leetcode, 课程表 II, BFS
---

### 题目说明
```

现在你总共有 n 门课需要选，记为 0 到 n-1。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]

给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。

可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。

示例 1:

输入: 2, [[1,0]] 
输出: [0,1]
解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
示例 2:

输入: 4, [[1,0],[2,0],[3,1],[3,2]]
输出: [0,1,2,3] or [0,2,1,3]
解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
说明:

输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。
你可以假定输入的先决条件中没有重复的边。
提示:

这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。
通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。
拓扑排序也可以通过 BFS 完成。
```

### 解题思路一
1. 首先要理解题意，该题的目的是要我们按依赖顺序排序。
2. 二维数组中，首位表示一门课程，数组余下的值表示，学习该课程之前所要完成的。例如[3,1],[3,2] 表示，最后的序列，`3要在2和1`的后面
3. 所以的我的做法是：以 `4, [[1,0],[2,0],[3,1],[3,2]]`为例
	1. 利用hash收集每门课程的前置课程：`{1:[0], 2:[0], 3:[1, 2], 0:[]}`,[]表示该门课程不需要前序课程，这种课程就可以直接放入序列中了。
	2. 第二步要做两件事：1. 将`前序为空`的课程`放入序列`，`删除`已经放入序列的课程。2. `遍历hash`，在各课程的前序课程中，`去掉`已经`放入序列`的`课程`。结果：hash：`{1:[], 2:[], 3:[1, 2]}`,序列res：`[0]`
	3. while循环直到res中包含了所有的课程`res.length === numCourses`
4. 以上是我们的大体思路，但是该题中还有一个问题。存在`循环前置`例如`[[0,1],[1,0]]`或者`[0,1][1,2][2,0]`等等，当课程存在这样的循环时，我们`无法得知`到底该`先学习`哪门课程。需要直接返回[]代表无法完成。
5. 该问题也很好解决，当我们`遍历hash找不到`任何一个前置课程为`[]`的课程时，表示存在循环引用了！这时候就可以返回`[]`了

### 代码实现一
```javascript
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {number[]}
 */
var findOrder = function(numCourses, prerequisites) {
    let hash = {};
    let res = [];
    //初始化hash表
    for(let i = 0; i < numCourses; i++) {
        hash[i] = [];
    }
    //收集课程的前置课程
    for(let i = 0; i < prerequisites.length; i++) {
        hash[prerequisites[i][0]] = Array.from(new Set([...hash[prerequisites[i][0]], ...prerequisites[i].slice(1)]));
    }
    // 遍历直到res排满
    while (res.length < numCourses) {
        let count = 0;//标记hash中的前序为空的课程。
        //遍历hash，碰到前序为空的，放入res，然后删除，最后在hash各课程的前序中去掉它。
        for (key in hash) {
            if (hash[key].length === 0) {
                count++;
                res.push(Number(key));
                delete hash[key]
                for (key2 in hash) {
                    hash[key2].indexOf(Number(key)) > -1 ? hash[key2].splice(hash[key2].indexOf(Number(key)), 1) : ''
                }
            }
        }
        // 如果遍历hash没有找到前置为空的课程，表示存在循环，返回[]
        if (!count) {
            return []
        }
    }
    return res;
};
```
