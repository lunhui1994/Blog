---
title: JavaScript：leecode_1371. 每个元音包含偶数次的最长子字符串（前缀和）
date: 2020-05-21 17:59:13
categories: ['Algorithm','每日一题']
tags: Algorithm
keywords: leetcode, 每个元音包含偶数次的最长子字符串, 前缀和
---

### 题目说明
```
给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。

 

示例 1：

输入：s = "eleetminicoworoep"
输出：13
解释：最长子字符串是 "leetminicowor" ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。
示例 2：

输入：s = "leetcodeisgreat"
输出：5
解释：最长子字符串是 "leetc" ，其中包含 2 个 e 。
示例 3：

输入：s = "bcbcbc"
输出：6
解释：这个示例中，字符串 "bcbcbc" 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。
 

提示：

1 <= s.length <= 5 x 10^5
s 只包含小写英文字母。
```
<!-- more -->

### 解题思路一
1. 首先要理解这个题。这道题明显还是跟`前缀`有关系的东西，毫无疑问肯定又需要用到`动态规划`保存状态。
2. 我们先来看子字符串中的各元音字母的个数，题目呢，要求的是`偶数次`，那么我们的` a，e，i，o，u`的出现次数是不是可以转化为出现`次数`的`奇偶性`呢？即
	1. `nums % 2 === 1 是奇数次`
	2. `nums % 2 === 0 是偶数次`
3. 那么我们的` a，e，i，o，u`的各自状态就只有两种情况啦，`0 or 1`，例如 
	```javascript
	'a': 0,
	'e': 0,
	'o': 1,
	'i': 0,
	'u': 0
	```
	那我们现在用二进制来表示一下它：`00100`， 那么类似于这样的表示有几种情况呢？ `2 x 2 x 2 x 2 x 2 = 32`仅仅只有`32`种情况，就可以完全表示元音字母的`所有状态`了。那么我们声明一个长度为`32`的`status`数组，值都初始化为`-1`。
4. 按照正常思维，符合条件的情况有两种子字符串，一是`从头开始`的，一个是从`中间开始`的。
	1. 从头开始的很容易理解（假设首位下标为`0，i`），只要从`0到i`，状态为`00000`就可以了。代表都是偶数次出现。
	2. 从中间开始的话（假设首位下标为`j，i`），是从`j到i`这个子字符串的状态为`00000`
	3. 那什么情况下子字符串的状态可以是00000呢？ 那当然是i，j各自的状态一致的时候，因为同状态互减才会为0，例如`01000 - 01000 = 00000`
	4. so，01000在字串中是会出现多次的，因为`2%2 == 0， 4%2===0`状态也是会重复的，所以我们想求出这个状态之间的最大间距，就要记录该状态`最早出现`的下标。
5. 好了，理解了这个状态之后，我们明确了我们要记录的值，记录该位置的状态下的最早下标。
6. 我们是不是可以记录一下，从`第1个字母开始到第i个字母之间`的各元音`状态`呢？
7. 例如：`"eleetminicoworoep"` 对应的状态数组`[01000,01000,00000,01000,01000,01000,01100...]`
8. `i 为 0，1，3，4，5` 的时候状态都一致，那么我们只需要记录`status[8] = 0,`取最小值即可。
9. 所以`status`数组记录的是32种状态各自在字符串中`最早出现的下标`
10. 最后我们遍历字符串，求出每一位的`状态key(例如01000)` ，根据这个`key和下标i`，我们去`status`里面找`key`的`最小下标status[key]`，然后用`i - status[key]`求出距离长度。若`status[key]为-1`，则将下标i赋值给`status[key] = i`


### 代码实现一
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var findTheLongestSubstring = function(s) {
    let hash = {
        'a': 0,
        'e': 0,
        'o': 0,
        'i': 0,
        'u': 0
    }
    let status = new Array(32).fill(-1);
    status[0] = 0;
    let max = 0;
     for (let i = 0; i < s.length; i++) {
        let key = 0;
        hash[s.charAt(i)] !== undefined ? hash[s.charAt(i)] = (hash[s.charAt(i)] + 1) % 2 : '';
        key += hash['a'] + (hash['e'] << 1) + (hash['i'] << 2) + (hash['o'] << 3) + (hash['u'] << 4)
        if (status[key] === -1) {
            status[key] = i + 1;
        } else {
            max = Math.max(max, i + 1 - status[key])
        }
    }
    return max;
};
```